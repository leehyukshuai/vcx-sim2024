# Rigid Body Lab报告

## Task 1: Single Rigid Body

### 类型实现：

`RigidBody`：task1最重要的内容是实现了RigidBody类型，它包含了一个刚体最基本的数据信息，比如密度质量速度位置等等，并且支持多种操作，譬如`void apply(glm::vec3 force, glm::vec3 position)`用来对刚体施加力， `void update(float delta)`代表用delta的时间更新刚体的速度和角速度信息，而最后的`void move(float delta)`代表用刚体的速度和角速度信息来更新刚体的位置和朝向。值得一提的是，RigidBody还有一个`bool isStatic`的标志量用来控制物体是不是静态的（比如地面和墙壁等）。

`Box`：Box是RigidBody的子类，扩充了一个dimension成员变量代表长宽高，并且覆写了SetInertia和SetMass的实现。
    
`BoxRenderItem`：包含了用来存储刚体数据的`Box box`，用来渲染的`UniqueIndexedRenderItem lineItem, faceItem`，并且支持了`void updateBuffer(void)`函数用来根据刚体信息更新vertexbuffer中的位置信息。

### 注意事项：

最开始忘记考虑了一件原则：角动量守恒，根据$L=I\omega$，由于旋转会导致惯性张量的改变，所以物体不一定保持恒定的角速度。因此应该用力矩更新角动量$L'=L+Torque\times \Delta t$，然后用$L=I\omega$来更新角速度，这样一来就可以展现出刚体的进动效果。

### Demo内容：

- 通过键盘的IKJLUO键来对刚体提供一个xyz轴上的作用力，使之平移
- 通过按住Alt的同时拖动鼠标为刚体提供一个力矩，使之旋转
- 可以直接在侧边栏修改物体的物理信息，比如速度位置阻力等

## Task 2: Collision Between Two Boxes

### 更新流程：

1. 对物体施加各种作用力，比如重力、阻力等
2. 根据第一步的作用力的合力，更新物体的速度和角速度
3. 处理碰撞，对物体施加冲量，改变物体的速度和角速度
4. 根据得到的速度和角速度更新物体的位置和朝向

需要说明的一点，第3步插在2、4步中间是非常重要的。如果先进行2、4步最后在进行碰撞检测的话，那么物体在地面上静止时会不断的下陷，因为重力提供向下的速度，而第4步会根据这个速度更新位置导致下坠，而最后进行的碰撞检测只能重置下坠速度为零，但是已经发生的下坠就无法挽回了。

### 多点碰撞：

我们有两种处理方案（都是非常基本的处理方式）：

1. 假设这些碰撞是按照相对碰撞速度按照次序发生的，每次先随机挑选一个碰撞，如果碰撞相对速度小于零，那么假设两个刚体此时只发生了这一个碰撞，然后按照Frictionless模型更新刚体的速度和角速度，直到处理完所有碰撞点为止。
2. 在计算完所有碰撞点造成的速度和角速度的改变量后，求和并除以碰撞点个数，最后再对两个刚体的速度和角速度进行更新。

虽然这两种方式都是不够物理真实的，但是对于精度要求不高的场景已经足够了。

### 类型实现：

`BoxCollisionSystem`：包含了当前场景中的所有物体的指针，先调用`collisionDetect`来记录所有的碰撞点，再调用`collisionHandle`来处理所有的碰撞。根据多点碰撞的两种处理方式，该类型提供了一个控制量`collisionMethod`，通过设置为`METHOD_NAIVE`就代表使用次序处理方式，通过设置为`METHOD_AVERAGE`就代表使用平均处理方式。

在`collisionHandle`，还需要对于Static Box的特殊处理：当一个刚体的`isStatic`标志为真，那么我们将其质量的倒数设置为0、转动惯量的逆设置为0矩阵，这样就能产生正常的碰撞效果。

### Demo内容：

1. 提供了三种场景供观察，分别是边边碰撞、点面碰撞、面面碰撞。
2. 可以通过设置coefficient of restitution来控制碰撞的恢复系数，从而可以观察完全弹性碰撞和塑性碰撞的效果。

## Task 3: Collision Between Multiple Rigid Bodys

这一部分的操作和Task 2基本一致，只是增加了物体的数量，并且在每轮更新时提供一个重力，另外还设置了几个特殊的物体的`isStatic`标志，代表他们是不可移动的地面和墙面。

### Demo内容：

- 通过按住Alt的同时拖动鼠标为所有的刚体提供一个平移作用力，使之平移；并且提供一个力矩，使之旋转。

### 待实现内容：

1. 通过继承RigidBody，我们可以写出很多子类，比如`Box`，`Sphere`，`Convex`等等不同的子类，来丰富场景的信息。
2. 当物体过多时，碰撞检测的效率会很低，这时我们可以通过broad phase和narrow phase的结合极大地提升检测的效率。
3. 可以提供多种处理碰撞和摩擦的方法，以增强程序的可复用性。