[TOC]

# Open Project报告

## Force-Base Physics Rigid Body Simulation

本次Open Project，基于lab1的刚体框架实现，并在此基础上，加入了以下新功能：

### 多类型物体的碰撞处理框架

实现一个多类型的物体的碰撞处理框架，具体而言，包括圆柱体`Cylinder`，正方体`Box`和球体`Sphere`等结构。

这一部分主要涉及到各个类型之间的耦合关系的解决，本lab将RigidBody物理数据、RenderItem渲染数据、CollisionItem碰撞数据分别进行包装，最后统一在Object物体类型中，而圆柱体、正方体、球体都是继承自Object，因此在后续过程中大大增加了代码效率。关于这部分可以考察`Object`、`Render`、`Collision`、`RigidBody`这四个文件的代码实现细节。

### Broad Phase预处理

加入Broad Phase的预处理，大大加速了碰撞检测的速度

这部分最开始打算使用`fcl::DynamicAABBTreeCollisionManager<float> manager`作为broad phase检测的具体实现，但是在实际运行过程中，发现这样会检测不到碰撞，研究很久仍未找到解决方案，遂采用妥协的办法，使用AABB做一个粗的碰撞检测，如果AABB有交叉，那就再在细节上求碰撞。虽然效率大大增加，但他本质上还是一个`O(n^2)`量级的算法。

### 多物体碰撞处理

更新碰撞处理的代码，加入对于摩擦的处理，从而增进模拟的现实感

本lab的碰撞处理主要包含以下内容：

#### 多点碰撞的处理

**假设所有碰撞都是间隔发生的**，本lab不考虑多点碰撞，因为不考虑多点碰撞，只有间隔发生的单点碰撞。基于此假设，lab的碰撞处理会出现抖动的问题，尤其是当多个物体相互挤压时。

#### 包含摩擦的处理

拿RBCollision一节的PPT作为说明。

<img src="assets/images/Open Proj报告.assets/image-20240609133004767.png" alt="image-20240609133004767" style="zoom:33%;" />

此处由于地板是staticbody，它的速度和K值都为0，因此我们可以改写公式为：
$$
v_{rel}^{new}-v_{rel}=Kj
$$

$$
K=K_a+K_b
$$

$$
K_a=\frac{1}{M_a}\bold{1}-(R_ar_a)^*I_a^{-1}(R_ar_a)^*
$$

$$
K_b=\frac{1}{M_b}\bold{1}-(R_br_b)^*I_b^{-1}(R_br_b)^*
$$

从性质上分析，当碰撞的物体一个比较轻（速度和角速度容易改变），另一个比较重（速度和角速度不容易改变）时，较重的物体的K值对于总K值的贡献较小，当它非常非常重以至于成为staticbody时，它的K值贡献为0，此时就和PPT上的例子一致了。本lab此处并不证明其模拟的正确性，只在大体上对其进行说明。并且根据实践，这种处理方式是plausible的。

#### 针对陷入的处理

1. 设置子步骤：无需多言，子步骤越多，模拟就越稳定。
2. 刚体更新顺序的调整：刚体的更新包含两个函数，一个是`update`，他负责更新刚体的状态的一阶导数，即速度，角速度等，另一个是`move`，他负责更新刚体状态本身，即位置，姿态等。之所以这样做，是为了在二者之间插入对于碰撞等constraint的处理，这样做可以一定程度上保证constraint的满足条件，因此大大减少了陷入的发生。
3. 接触解除：如果勾选了`solve contact`参数，那么碰撞处理时就会对产生陷入的物体对进行分离，不过偶尔这会导致抖动的发生，尤其是多个物体相互挤压的时候。

#### 碰撞参数的处理

$\mu_N$和$\mu_T$​二者都是针对于碰撞对的材料而定的，此处为了方便，仅假设所有的材料都是相同的，具有一样的摩擦系数。不过对于CaseCar来说，还需要消除轮胎和车体之间的摩擦，所以加了一些比较tricky的mask方法。

### 基于约束的登山越野车

最后，基于以上新功能，本次project实现了一个登山越野车，轮子和车体是靠约束连接，靠轮子自转产生的和地面之间的摩擦产生驱动力。

碰撞是对于距离约束的一种，而轮子和车体之间的连接也是一种对于位置和朝向的约束。不过，对于碰撞的处理，我们的解决方案是**Impulse**瞬间处理，利用冲量改变速度；而对于后者，我们可以用**Penalty**带来的Force来实现，这种约束较软，因此偶尔会发生抖动的现象，不过在damping机制下，物体的抖动也会被自然解决。

具体而言，每个轮子和与他接触的车体的底部都包含了四处distance constraint，并且根据他们和rest shape下的偏差产生一个恢复的作用力。

## Lab包含的Cases

### CaseNaive

这个case创建了一个基本包含了所有功能的最小例程，可以通过按住`Alt`键并拖动鼠标来控制小球的旋转。

<img src="assets/images/Open Proj报告.assets/image-20240609124232239.png" alt="image-20240609124232239" style="zoom:33%;" />

此处可以调整的参数中，miu_T和miu_N这两个摩擦系数是比较有趣的，分别控制法向上的恢复程度和切向上的摩擦力。

solve contact代表是否启用接触解除，xray代表是否使用透视。

### CaseCollide

这个case展现了多个物体碰撞的效果，值得注意的是，碰撞的效果是很不错的，基本没有penetration的发生，即使偶尔发生抖动，也不会产生崩坏。

<img src="assets/images/Open Proj报告.assets/image-20240609141511013.png" alt="image-20240609141511013" style="zoom:33%;" />

![image-20240609141641992](assets/images/Open Proj报告.assets/image-20240609141641992.png)

可以看出，底面上的球体和箱体都没有发生嵌入地面的情况，四周的墙面也保持的很好。

### CaseCar

这个case实现了一个新概念车，它的轮子是可以任意旋转的，轮子和车体之间依靠磁悬浮力（一个distance constraint）来固定。

<img src="assets/images/Open Proj报告.assets/image-20240609141938812.png" alt="image-20240609141938812" style="zoom:33%;" />

这个demo的亮点在于，小车是完全依靠轮子与地面的摩擦带动的。可以观察轮子的轮纹来看出小车目前的移动状态。

通过`IJKL`可以实现前进后退旋转操作，分号`;`代表刹车操作。

通过调整torque（轮子扭矩），brake（刹车扭矩），miu_T（地面摩擦力），我们也可以实现飙车，还可以出现侧翻的情况。但缺陷就是通过penalty实现的distance constraint是一个soft约束，因此当小车速度太快时，轮子会抖动的比较厉害。

此处通过设置相机的观察焦点始终是小车，用户观察起来更加方便。

## 总结

这次的lab仍有很多缺陷和不足，譬如由于fcl库对于圆柱体等复杂物体的碰撞检测返回的接触点较为古怪，所以圆柱体会很容易陷入或抖动；broad phase阶段仍然没有搞清楚如何用fcl库来实现bvh树；软约束强度相较于XPBD方法，不够稳固等等。但目前他已经是一个基本可以运行的框架了，也是圆了我从大一刚开始学计算概论开始就树立下的做一个刚体仿真的愿望。

接下来其实我最感兴趣的还是如何利用constraint-based的方法来实现一个真正稳定的刚体模拟器（尤其是对于contact的处理！），同时也想用position-based的方法来实现一个快速的、可以包含软体甚至流体交互的物理模拟器。不过这些都是后话，现在，还是赶紧复习期末考试以及补好其他的作业吧www。
